{"mappings":"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","sources":["src/jquery-csv.js"],"sourcesContent":["/* eslint no-prototype-builtins: 0 */\n/**\n * jQuery-csv (jQuery Plugin)\n *\n * This document is licensed as free software under the terms of the\n * MIT License: http://www.opensource.org/licenses/mit-license.php\n *\n * Acknowledgements:\n * The original design and influence to implement this library as a jquery\n * plugin is influenced by jquery-json (http://code.google.com/p/jquery-json/).\n * If you're looking to use native JSON.Stringify but want additional backwards\n * compatibility for browsers that don't support it, I highly recommend you\n * check it out.\n *\n * A special thanks goes out to rwk@acm.org for providing a lot of valuable\n * feedback to the project including the core for the new FSM\n * (Finite State Machine) parsers. If you're looking for a stable TSV parser\n * be sure to take a look at jquery-tsv (http://code.google.com/p/jquery-tsv/).\n\n * For legal purposes I'll include the \"NO WARRANTY EXPRESSED OR IMPLIED.\n * USE AT YOUR OWN RISK.\". Which, in 'layman's terms' means, by using this\n * library you are accepting responsibility if it breaks your code.\n *\n * Legal jargon aside, I will do my best to provide a useful and stable core\n * that can effectively be built on.\n *\n * Copyrighted 2012 by Evan Plaice.\n */\n\nRegExp.escape = function (s) {\n  return s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n};\n\n(function () {\n  'use strict'\n\n  let $\n\n  // to keep backwards compatibility\n  if (typeof jQuery !== 'undefined' && jQuery) {\n    $ = jQuery\n  } else {\n    $ = {}\n  }\n\n  /**\n   * jQuery.csv.defaults\n   * Encapsulates the method paramater defaults for the CSV plugin module.\n   */\n\n  $.csv = {\n    defaults: {\n      separator: ',',\n      delimiter: '\"',\n      headers: true\n    },\n\n    hooks: {\n      castToScalar: function (value, state) {\n        const hasDot = /\\./\n        if (isNaN(value)) {\n          return value\n        } else {\n          if (hasDot.test(value)) {\n            return parseFloat(value)\n          } else {\n            const integer = parseInt(value)\n            if (isNaN(integer)) {\n              return null\n            } else {\n              return integer\n            }\n          }\n        }\n      }\n    },\n\n    parsers: {\n      parse: function (csv, options) {\n        // cache settings\n        const separator = options.separator\n        const delimiter = options.delimiter\n\n        // set initial state if it's missing\n        if (!options.state.rowNum) {\n          options.state.rowNum = 1\n        }\n        if (!options.state.colNum) {\n          options.state.colNum = 1\n        }\n\n        // clear initial state\n        const data = []\n        let entry = []\n        let state = 0\n        let value = ''\n        let exit = false\n\n        function endOfEntry () {\n          // reset the state\n          state = 0\n          value = ''\n\n          // if 'start' hasn't been met, don't output\n          if (options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = []\n            options.state.rowNum++\n            options.state.colNum = 1\n            return\n          }\n\n          if (options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            data.push(entry)\n          } else {\n            const hookVal = options.onParseEntry(entry, options.state) // onParseEntry Hook\n            // false skips the row, configurable through a hook\n            if (hookVal !== false) {\n              data.push(hookVal)\n            }\n          }\n          // console.log('entry:' + entry);\n\n          // cleanup\n          entry = []\n\n          // if 'end' is met, stop parsing\n          if (options.end && options.state.rowNum >= options.end) {\n            exit = true\n          }\n\n          // update global state\n          options.state.rowNum++\n          options.state.colNum = 1\n        }\n\n        function endOfValue () {\n          if (options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value)\n          } else if (options.headers && options.state.rowNum === 1) {\n            // don't onParseValue object headers\n            entry.push(value)\n          } else {\n            const hook = options.onParseValue(value, options.state) // onParseValue Hook\n            // false skips the row, configurable through a hook\n            if (hook !== false) {\n              entry.push(hook)\n            }\n          }\n          // console.log('value:' + value);\n          // reset the state\n          value = ''\n          state = 0\n          // update global state\n          options.state.colNum++\n        }\n\n        // escape regex-specific control chars\n        const escSeparator = RegExp.escape(separator)\n        const escDelimiter = RegExp.escape(delimiter)\n\n        // compile the regEx str using the custom delimiter/separator\n        let match = /(D|S|\\r\\n|\\n|\\r|[^DS\\r\\n]+)/\n        let matchSrc = match.source\n        matchSrc = matchSrc.replace(/S/g, escSeparator)\n        matchSrc = matchSrc.replace(/D/g, escDelimiter)\n        match = new RegExp(matchSrc, 'gm')\n\n        // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n        csv.replace(match, function (m0) {\n          if (exit) {\n            return\n          }\n          switch (state) {\n            // the start of a value\n            case 0:\n              // null last value\n              if (m0 === separator) {\n                value += ''\n                endOfValue()\n                break\n              }\n              // opening delimiter\n              if (m0 === delimiter) {\n                state = 1\n                break\n              }\n              // null last value\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue()\n                endOfEntry()\n                break\n              }\n              // un-delimited value\n              value += m0\n              state = 3\n              break\n\n            // delimited input\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                state = 2\n                break\n              }\n              // delimited data\n              value += m0\n              state = 1\n              break\n\n            // delimiter found in delimited input\n            case 2:\n              // escaped delimiter?\n              if (m0 === delimiter) {\n                value += m0\n                state = 1\n                break\n              }\n              // null value\n              if (m0 === separator) {\n                endOfValue()\n                break\n              }\n              // end of entry\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue()\n                endOfEntry()\n                break\n              }\n              // broken paser?\n              throw Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n\n            // un-delimited input\n            case 3:\n              // null last value\n              if (m0 === separator) {\n                endOfValue()\n                break\n              }\n              // end of entry\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue()\n                endOfEntry()\n                break\n              }\n              if (m0 === delimiter) {\n              // non-compliant data\n                throw Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n              }\n              // broken parser?\n              throw Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n            default:\n              // shenanigans\n              throw Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n          }\n          // console.log('val:' + m0 + ' state:' + state);\n        })\n\n        // submit the last entry\n        // ignore null last line\n        if (entry.length !== 0) {\n          endOfValue()\n          endOfEntry()\n        }\n\n        return data\n      },\n\n      // a csv-specific line splitter\n      splitLines: function (csv, options) {\n        if (!csv) {\n          return undefined\n        }\n\n        options = options || {}\n\n        // cache settings\n        const separator = options.separator || $.csv.defaults.separator\n        const delimiter = options.delimiter || $.csv.defaults.delimiter\n\n        // set initial state if it's missing\n        options.state = options.state || {}\n        if (!options.state.rowNum) {\n          options.state.rowNum = 1\n        }\n\n        // clear initial state\n        const entries = []\n        let state = 0\n        let entry = ''\n        let exit = false\n\n        function endOfLine () {\n          // reset the state\n          state = 0\n\n          // if 'start' hasn't been met, don't output\n          if (options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = ''\n            options.state.rowNum++\n            return\n          }\n\n          if (options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            entries.push(entry)\n          } else {\n            const hookVal = options.onParseEntry(entry, options.state) // onParseEntry Hook\n            // false skips the row, configurable through a hook\n            if (hookVal !== false) {\n              entries.push(hookVal)\n            }\n          }\n\n          // cleanup\n          entry = ''\n\n          // if 'end' is met, stop parsing\n          if (options.end && options.state.rowNum >= options.end) {\n            exit = true\n          }\n\n          // update global state\n          options.state.rowNum++\n        }\n\n        // escape regex-specific control chars\n        const escSeparator = RegExp.escape(separator)\n        const escDelimiter = RegExp.escape(delimiter)\n\n        // compile the regEx str using the custom delimiter/separator\n        let match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/\n        let matchSrc = match.source\n        matchSrc = matchSrc.replace(/S/g, escSeparator)\n        matchSrc = matchSrc.replace(/D/g, escDelimiter)\n        match = new RegExp(matchSrc, 'gm')\n\n        // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n        csv.replace(match, function (m0) {\n          if (exit) {\n            return\n          }\n          switch (state) {\n            // the start of a value/entry\n            case 0:\n              // null value\n              if (m0 === separator) {\n                entry += m0\n                state = 0\n                break\n              }\n              // opening delimiter\n              if (m0 === delimiter) {\n                entry += m0\n                state = 1\n                break\n              }\n              // end of line\n              if (m0 === '\\n') {\n                endOfLine()\n                break\n              }\n              // phantom carriage return\n              if (/^\\r$/.test(m0)) {\n                break\n              }\n              // un-delimit value\n              entry += m0\n              state = 3\n              break\n\n            // delimited input\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                entry += m0\n                state = 2\n                break\n              }\n              // delimited data\n              entry += m0\n              state = 1\n              break\n\n            // delimiter found in delimited input\n            case 2: {\n              // escaped delimiter?\n              const prevChar = entry.substr(entry.length - 1)\n              if (m0 === delimiter && prevChar === delimiter) {\n                entry += m0\n                state = 1\n                break\n              }\n              // end of value\n              if (m0 === separator) {\n                entry += m0\n                state = 0\n                break\n              }\n              // end of line\n              if (m0 === '\\n') {\n                endOfLine()\n                break\n              }\n              // phantom carriage return\n              if (m0 === '\\r') {\n                break\n              }\n              // broken paser?\n              throw Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']')\n            }\n            // un-delimited input\n            case 3:\n              // null value\n              if (m0 === separator) {\n                entry += m0\n                state = 0\n                break\n              }\n              // end of line\n              if (m0 === '\\n') {\n                endOfLine()\n                break\n              }\n              // phantom carriage return\n              if (m0 === '\\r') {\n                break\n              }\n              // non-compliant data\n              if (m0 === delimiter) {\n                throw Error('CSVDataError: Illegal quote [Row:' + options.state.rowNum + ']')\n              }\n              // broken parser?\n              throw Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']')\n            default:\n              // shenanigans\n              throw Error('CSVDataError: Unknown state [Row:' + options.state.rowNum + ']')\n          }\n          // console.log('val:' + m0 + ' state:' + state);\n        })\n\n        // submit the last entry\n        // ignore null last line\n        if (entry !== '') {\n          endOfLine()\n        }\n\n        return entries\n      },\n\n      // a csv entry parser\n      parseEntry: function (csv, options) {\n        // cache settings\n        const separator = options.separator\n        const delimiter = options.delimiter\n\n        // set initial state if it's missing\n        if (!options.state.rowNum) {\n          options.state.rowNum = 1\n        }\n        if (!options.state.colNum) {\n          options.state.colNum = 1\n        }\n\n        // clear initial state\n        const entry = []\n        let state = 0\n        let value = ''\n\n        function endOfValue () {\n          if (options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value)\n          } else {\n            const hook = options.onParseValue(value, options.state) // onParseValue Hook\n            // false skips the value, configurable through a hook\n            if (hook !== false) {\n              entry.push(hook)\n            }\n          }\n          // reset the state\n          value = ''\n          state = 0\n          // update global state\n          options.state.colNum++\n        }\n\n        // checked for a cached regEx first\n        if (!options.match) {\n          // escape regex-specific control chars\n          const escSeparator = RegExp.escape(separator)\n          const escDelimiter = RegExp.escape(delimiter)\n\n          // compile the regEx str using the custom delimiter/separator\n          const match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/\n          let matchSrc = match.source\n          matchSrc = matchSrc.replace(/S/g, escSeparator)\n          matchSrc = matchSrc.replace(/D/g, escDelimiter)\n          options.match = new RegExp(matchSrc, 'gm')\n        }\n\n        // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n        csv.replace(options.match, function (m0) {\n          switch (state) {\n            // the start of a value\n            case 0:\n              // null last value\n              if (m0 === separator) {\n                value += ''\n                endOfValue()\n                break\n              }\n              // opening delimiter\n              if (m0 === delimiter) {\n                state = 1\n                break\n              }\n              // skip un-delimited new-lines\n              if (m0 === '\\n' || m0 === '\\r') {\n                break\n              }\n              // un-delimited value\n              value += m0\n              state = 3\n              break\n\n            // delimited input\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                state = 2\n                break\n              }\n              // delimited data\n              value += m0\n              state = 1\n              break\n\n            // delimiter found in delimited input\n            case 2:\n              // escaped delimiter?\n              if (m0 === delimiter) {\n                value += m0\n                state = 1\n                break\n              }\n              // null value\n              if (m0 === separator) {\n                endOfValue()\n                break\n              }\n              // skip un-delimited new-lines\n              if (m0 === '\\n' || m0 === '\\r') {\n                break\n              }\n              // broken paser?\n              throw Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n\n            // un-delimited input\n            case 3:\n              // null last value\n              if (m0 === separator) {\n                endOfValue()\n                break\n              }\n              // skip un-delimited new-lines\n              if (m0 === '\\n' || m0 === '\\r') {\n                break\n              }\n              // non-compliant data\n              if (m0 === delimiter) {\n                throw Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n              }\n              // broken parser?\n              throw Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n            default:\n              // shenanigans\n              throw Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n          }\n          // console.log('val:' + m0 + ' state:' + state);\n        })\n\n        // submit the last value\n        endOfValue()\n\n        return entry\n      }\n    },\n\n    helpers: {\n\n      /**\n       * $.csv.helpers.collectPropertyNames(objectsArray)\n       * Collects all unique property names from all passed objects.\n       *\n       * @param {Array} objects Objects to collect properties from.\n       *\n       * Returns an array of property names (array will be empty,\n       * if objects have no own properties).\n       */\n      collectPropertyNames: function (objects) {\n        let o = []\n        let propName = []\n        const props = []\n        for (o in objects) {\n          for (propName in objects[o]) {\n            if ((objects[o].hasOwnProperty(propName)) &&\n                (props.indexOf(propName) < 0) &&\n                (typeof objects[o][propName] !== 'function')) {\n              props.push(propName)\n            }\n          }\n        }\n        return props\n      }\n    },\n\n    /**\n     * $.csv.toArray(csv)\n     * Converts a CSV entry string to a javascript array.\n     *\n     * @param {Array} csv The string containing the CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method deals with simple CSV strings only. It's useful if you only\n     * need to parse a single entry. If you need to parse more than one line,\n     * use $.csv2Array instead.\n     */\n    toArray: function (csv, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n      }\n\n      options = (options !== undefined ? options : {})\n      const config = {}\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter\n      const state = (options.state !== undefined ? options.state : {})\n\n      // setup\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        state: state\n      }\n\n      const entry = $.csv.parsers.parseEntry(csv, options)\n\n      // push the value to a callback if one is defined\n      if (!config.callback) {\n        return entry\n      } else {\n        config.callback('', entry)\n      }\n    },\n\n    /**\n     * $.csv.toArrays(csv)\n     * Converts a CSV string to a javascript array.\n     *\n     * @param {String} csv The string containing the raw CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method deals with multi-line CSV. The breakdown is simple. The first\n     * dimension of the array represents the line (or entry/row) while the second\n     * dimension contains the values (or values/columns).\n     */\n    toArrays: function (csv, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n      }\n\n      options = (options !== undefined ? options : {})\n      const config = {}\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter\n\n      // setup\n      let data = []\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        }\n      }\n\n      // onPreParse hook\n      if (options.onPreParse !== undefined) {\n        csv = options.onPreParse(csv, options.state)\n      }\n\n      // parse the data\n      data = $.csv.parsers.parse(csv, options)\n\n      // onPostParse hook\n      if (options.onPostParse !== undefined) {\n        data = options.onPostParse(data, options.state)\n      }\n\n      // push the value to a callback if one is defined\n      if (!config.callback) {\n        return data\n      } else {\n        config.callback('', data)\n      }\n    },\n\n    /**\n     * $.csv.toObjects(csv)\n     * Converts a CSV string to a javascript object.\n     * @param {String} csv The string containing the raw CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     * @param {Boolean} [headers] Indicates whether the data contains a header line. Defaults to true.\n     *\n     * This method deals with multi-line CSV strings. Where the headers line is\n     * used as the key for each value per entry.\n     */\n    toObjects: function (csv, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n      }\n\n      options = (options !== undefined ? options : {})\n      const config = {}\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers\n      options.start = 'start' in options ? options.start : 1\n\n      // account for headers\n      if (config.headers) {\n        options.start++\n      }\n      if (options.end && config.headers) {\n        options.end++\n      }\n\n      // setup\n      let lines = []\n      let data = []\n\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        },\n        match: false,\n        transform: options.transform\n      }\n\n      // fetch the headers\n      const headerOptions = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        start: 1,\n        end: 1,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        },\n        headers: true\n      }\n\n      // onPreParse hook\n      if (options.onPreParse !== undefined) {\n        csv = options.onPreParse(csv, options.state)\n      }\n\n      // parse the csv\n      const headerLine = $.csv.parsers.splitLines(csv, headerOptions)\n      const headers = $.csv.toArray(headerLine[0], headerOptions)\n\n      // fetch the data\n      lines = $.csv.parsers.splitLines(csv, options)\n\n      // reset the state for re-use\n      options.state.colNum = 1\n      if (headers) {\n        options.state.rowNum = 2\n      } else {\n        options.state.rowNum = 1\n      }\n\n      // convert data to objects\n      for (let i = 0, len = lines.length; i < len; i++) {\n        const entry = $.csv.toArray(lines[i], options)\n        const object = {}\n        for (let j = 0; j < headers.length; j++) {\n          object[headers[j]] = entry[j]\n        }\n        if (options.transform !== undefined) {\n          data.push(options.transform.call(undefined, object))\n        } else {\n          data.push(object)\n        }\n\n        // update row state\n        options.state.rowNum++\n      }\n\n      // onPostParse hook\n      if (options.onPostParse !== undefined) {\n        data = options.onPostParse(data, options.state)\n      }\n\n      // push the value to a callback if one is defined\n      if (!config.callback) {\n        return data\n      } else {\n        config.callback('', data)\n      }\n    },\n\n    /**\n    * $.csv.fromArrays(arrays)\n    * Converts a javascript array to a CSV String.\n    *\n    * @param {Array} arrays An array containing an array of CSV entries.\n    * @param {Object} [options] An object containing user-defined options.\n    * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n    * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n    *\n    * This method generates a CSV file from an array of arrays (representing entries).\n    */\n    fromArrays: function (arrays, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n      }\n\n      options = (options !== undefined ? options : {})\n      const config = {}\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter\n\n      let output = ''\n\n      for (let i = 0; i < arrays.length; i++) {\n        const line = arrays[i]\n        const lineValues = []\n        for (let j = 0; j < line.length; j++) {\n          let strValue = (line[j] === undefined || line[j] === null) ? '' : line[j].toString()\n          if (strValue.indexOf(config.delimiter) > -1) {\n            strValue = strValue.replace(new RegExp(config.delimiter, 'g'), config.delimiter + config.delimiter)\n          }\n\n          let escMatcher = '\\n|\\r|S|D'\n          escMatcher = escMatcher.replace('S', config.separator)\n          escMatcher = escMatcher.replace('D', config.delimiter)\n\n          if (strValue.search(escMatcher) > -1) {\n            strValue = config.delimiter + strValue + config.delimiter\n          }\n          lineValues.push(strValue)\n        }\n        output += lineValues.join(config.separator) + '\\n'\n      }\n\n      // push the value to a callback if one is defined\n      if (!config.callback) {\n        return output\n      } else {\n        config.callback('', output)\n      }\n    },\n\n    /**\n     * $.csv.fromObjects(objects)\n     * Converts a javascript dictionary to a CSV string.\n     *\n     * @param {Object} objects An array of objects containing the data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     * @param {Character} [sortOrder] Sort order of columns (named after\n     *   object properties). Use 'alpha' for alphabetic. Default is 'declare',\n     *   which means, that properties will _probably_ appear in order they were\n     *   declared for the object. But without any guarantee.\n     * @param {Character or Array} [manualOrder] Manually order columns. May be\n     * a strin in a same csv format as an output or an array of header names\n     * (array items won't be parsed). All the properties, not present in\n     * `manualOrder` will be appended to the end in accordance with `sortOrder`\n     * option. So the `manualOrder` always takes preference, if present.\n     *\n     * This method generates a CSV file from an array of objects (name:value pairs).\n     * It starts by detecting the headers and adding them as the first line of\n     * the CSV file, followed by a structured dump of the data.\n     */\n    fromObjects: function (objects, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n      }\n\n      options = (options !== undefined ? options : {})\n      const config = {}\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers\n      config.sortOrder = 'sortOrder' in options ? options.sortOrder : 'declare'\n      config.manualOrder = 'manualOrder' in options ? options.manualOrder : []\n      config.transform = options.transform\n\n      if (typeof config.manualOrder === 'string') {\n        config.manualOrder = $.csv.toArray(config.manualOrder, config)\n      }\n\n      if (config.transform !== undefined) {\n        const origObjects = objects\n        objects = []\n\n        for (let i = 0; i < origObjects.length; i++) {\n          objects.push(config.transform.call(undefined, origObjects[i]))\n        }\n      }\n\n      let props = $.csv.helpers.collectPropertyNames(objects)\n\n      if (config.sortOrder === 'alpha') {\n        props.sort()\n      }\n\n      if (config.manualOrder.length > 0) {\n        const propsManual = [].concat(config.manualOrder)\n\n        for (let p = 0; p < props.length; p++) {\n          if (propsManual.indexOf(props[p]) < 0) {\n            propsManual.push(props[p])\n          }\n        }\n        props = propsManual\n      }\n\n      let line\n      const output = []\n      let propName\n      if (config.headers) {\n        output.push(props)\n      }\n\n      for (let o = 0; o < objects.length; o++) {\n        line = []\n        for (let p = 0; p < props.length; p++) {\n          propName = props[p]\n          if (propName in objects[o] && typeof objects[o][propName] !== 'function') {\n            line.push(objects[o][propName])\n          } else {\n            line.push('')\n          }\n        }\n        output.push(line)\n      }\n\n      // push the value to a callback if one is defined\n      return $.csv.fromArrays(output, options, config.callback)\n    }\n  }\n\n  // Maintenance code to maintain backward-compatibility\n  // Will be removed in release 1.0\n  $.csvEntry2Array = $.csv.toArray\n  $.csv2Array = $.csv.toArrays\n  $.csv2Dictionary = $.csv.toObjects\n\n  // CommonJS module is defined\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = $.csv\n  }\n}).call(this)\n"],"names":[],"version":3,"file":"index.ba19e49b.js.map","sourceRoot":"/__parcel_source_root/"}